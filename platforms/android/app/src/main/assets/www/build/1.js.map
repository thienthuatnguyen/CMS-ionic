{"version":3,"sources":["../../src/pages/test-drive-record/test-drive-record.module.ts","../../src/pipes/pipes.module.ts","../../src/pipes/hours-minutes-seconds/hours-minutes-seconds.ts","../../src/pipes/time-duration/time-duration.ts","../../src/pages/test-drive-record/test-drive-record.ts","../../node_modules/moment-duration-format/lib/moment-duration-format.js"],"names":[],"mappings":"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AEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,6BAA6B;AAC7B,yCAAyC;AACzC,0BAA0B;AAC1B,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,aAAa,iCAAiC;AAC9C,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,QAAQ;;AAErC;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,YAAY;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,gBAAgB;AACvC,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,cAAc;AAC/C,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,cAAc;AAC9C,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,eAAe;AACvD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,cAAc;;AAE3C;AACA,yDAAyD,aAAa;AACtE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,cAAc;;AAEpC;AACA,qDAAqD,0BAA0B;AAC/E,qDAAqD,0BAA0B;AAC/E,qDAAqD,0BAA0B;AAC/E,sBAAsB,cAAc;;AAEpC;AACA,yDAAyD,qDAAqD;AAC9G,yDAAyD,qDAAqD;AAC9G,yDAAyD,qDAAqD;AAC9G,yDAAyD,qDAAqD;AAC9G,sBAAsB,cAAc;;AAEpC;AACA,yDAAyD,8BAA8B;AACvF,yDAAyD,8BAA8B;AACvF,yDAAyD,8BAA8B;AACvF,yDAAyD,8BAA8B;AACvF,yDAAyD,8BAA8B;AACvF,sBAAsB,cAAc;;AAEpC;AACA,wDAAwD,oBAAoB;AAC5E,wDAAwD,qBAAqB;AAC7E,sBAAsB,cAAc;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,oBAAoB;AAC5E;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,aAAa;;AAEb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,CAAC","file":"1.js","sourcesContent":["import { NgModule } from '@angular/core';\nimport { IonicPageModule } from 'ionic-angular';\nimport { TestDriveRecordPage } from './test-drive-record';\nimport {TranslateModule} from \"@ngx-translate/core\";\nimport {PipesModule} from \"../../pipes/pipes.module\";\n\n@NgModule({\n  declarations: [\n    TestDriveRecordPage\n  ],\n  imports: [\n    IonicPageModule.forChild(TestDriveRecordPage),\n    TranslateModule.forChild(),\n    PipesModule\n  ]\n})\nexport class TestDriveRecordPageModule {}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/test-drive-record/test-drive-record.module.ts","import { NgModule } from '@angular/core';\nimport { HoursMinutesSeconds } from './hours-minutes-seconds/hours-minutes-seconds';\nimport { TimeDuration } from './time-duration/time-duration';\n@NgModule({\n\tdeclarations: [HoursMinutesSeconds, TimeDuration\n    ],\n\timports: [],\n\texports: [HoursMinutesSeconds, TimeDuration\n    ]\n})\nexport class PipesModule {}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pipes/pipes.module.ts","import {Injectable, Pipe, PipeTransform} from '@angular/core';\n//import * as _moment from 'moment';\nimport * as moment from 'moment';\n\n// const Moment = _moment;\n/**\n * Generated class for the HoursMinutesSecondsPipe pipe.\n *\n * See https://angular.io/api/core/Pipe for more info on Angular Pipes.\n */\n@Pipe({\n  name: 'hoursMinutesSeconds',\n})\nexport class HoursMinutesSeconds implements PipeTransform {\n  /**\n   * Takes a value and makes it lowercase.\n   */\n\n  transform(value, args?) {\n\n    // let sec_num = parseInt(value, 10);\n    let momentDateString = moment((parseInt(value)*1000)).utcOffset(0).format('HH:mm:ss')\n\n    // momentDateString =(parseInt(value)*1000)\n\n\n\n    // let momentDateString = moment(new Date(sec_num)).format('hh:mm:ss')\n    return momentDateString;\n  }\n    /*if (hours != 0) {\n      time = hours+\":\";\n    }\n    if (minutes != 0 || time !== \"\") {npm\n      minutes = (minutes < 10 && time !== \"\") ? \"0\"+minutes : String(minutes);\n      time += minutes+\":\";\n    }\n    if (time === \"\") {\n      time = seconds+\"s\";\n    }\n    else {\n      time += (seconds < 10) ? \"0\"+seconds : String(seconds);\n    }\n    return time;\n  }*/\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pipes/hours-minutes-seconds/hours-minutes-seconds.ts","import {Pipe, PipeTransform} from '@angular/core';\nimport * as moment from 'moment';\n\n@Pipe({\n  name: 'timeDuration',\n})\nexport class TimeDuration implements PipeTransform {\n  transform(value, args?) {\n    const day = 60 * 60;\n    let timeDuration = '';\n\n    if(value > day) {\n        timeDuration = Math.floor(value / day) + 'D+';\n    }\n    else {\n      let time = moment((parseInt(value)*1000)).utcOffset(0);\n      timeDuration = time.format('H') + 'H ' + time.format('mm') + 'M';\n    }\n    \n    return timeDuration;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pipes/time-duration/time-duration.ts","import { Component } from '@angular/core';\nimport { AlertController, IonicPage, LoadingController, ModalController, NavController, NavParams } from 'ionic-angular';\n\nimport { Items, Util } from '../../providers';\nimport { TestDriveResultPage } from \"../test-drive-result/test-drive-result\";\nimport { TranslateService } from \"@ngx-translate/core\";\nimport * as moment from 'moment';\nimport 'moment-duration-format';\nimport { RealTimeCheckProvider } from \"../../providers/real-time-check/real-time-check\";\nimport { RealTimeItems } from \"../../models/realtimeItems\";\nimport { Geolocation } from \"@ionic-native/geolocation\";\nimport { TestDrivingModel } from \"../../models/testDrivingModel\";\nimport { TestDriveProvider } from \"../../providers/test-drive/test-drive\";\nimport { Subscription } from \"rxjs/Subscription\";\nimport { APICode, APIResponse } from \"@ivt/http-client\";\nimport { IvtStorageService } from \"@ivt/security\";\nimport { DrivingRecordRequest, DrivingRecordService, DrivingRecord, DrivingLocation, DrivingRawRecordsRequest } from '../../services/driving.record.service';\nimport { Observable } from 'rxjs/Observable';\nimport { BackgroundGeolocation, BackgroundGeolocationResponse } from '@ionic-native/background-geolocation';\nimport { GeoService } from '../../services/geo.service';\nimport { LoadingService } from '../../services/loading.service';\nimport { ToastService } from '../../services/toast.service';\nimport { TaskQueueService, TaskQueue, QUEUE_INTERVAL, Task } from '../../services/task.queue.service';\nimport { retry } from 'rxjs/operators';\n\n\n/**\n * Generated class for the TestDriveRecordPage page.\n *\n * See https://ionicframework.com/docs/components/#navigation for more info on\n * Ionic pages and navigation.\n */\n\n@IonicPage()\n@Component({\n  selector: 'page-test-drive-record',\n  templateUrl: 'test-drive-record.html',\n})\nexport class TestDriveRecordPage {\n\n  queue: TaskQueue;\n  private readonly RECORD_SIZE = 5; // how many recording locations we post to server at a time\n  private readonly POST_TIMEOUT = 20000; // what is interval to post recording locations\n  private tabElement: any;\n  private lastRecordedLocation: BackgroundGeolocationResponse;\n  private lastPostRecordOrder: number = 0;\n\n  private timeout: any;\n\n  private getAddress() {\n    this.drivingRecordService.getFormattedAddress({\n      latitude: this.drivingRecordRequest.startLatitude,\n      longitude: this.drivingRecordRequest.startLongitude,\n      language: null\n    }).toPromise().then(\n      val => this.startAddress = val\n    );\n  }\n  okString: any;\n  cancelString: any;\n\n  recordId: any;\n  confirmWord: string;\n  item: any;\n  startAddress: string\n\n  drivenMileage: number\n\n  displayDrivenDurationInSec: string;\n  timePassed: moment.Duration;\n  drivingRecordRequest: DrivingRecordRequest;\n  isTestDriving: boolean = true;\n  timer: NodeJS.Timer;\n\n  playButtonIcon = 'pause';\n\n  constructor(\n    public navCtrl: NavController,\n    public navParams: NavParams,\n    private items: Items,\n    private alertCtrl: AlertController,\n    private translate: TranslateService,\n    public util: Util,\n    private testDriveProvider: TestDriveProvider,\n    private geolocation: Geolocation,\n    private storageService: IvtStorageService,\n    private loadingCtrl: LoadingController,\n    private drivingRecordService: DrivingRecordService,\n    private geoService: GeoService,\n    private loadingSvc: LoadingService,\n    private toastSvc: ToastService,\n    private taskQueueService: TaskQueueService\n  ) {\n\n    this.confirmWord = \"\";\n\n    this.tabElement = document.querySelector('.tabbar')\n    this.displayTab('none');\n\n    this.item = navParams.get('item'); //Reservation Number가져와야 함.\n    this.recordId = navParams.get('recordId');\n\n    translate.get('ENDTESTDRIVE_CONFIRM').subscribe((value) => {\n      this.confirmWord = value;\n    })\n\n    translate.get('CANCEL_BUTTON').subscribe((value) => {\n      this.cancelString = value;\n    })\n\n    translate.get('OK_BUTTON').subscribe((value) => {\n      this.okString = value;\n    });\n\n    this.drivingRecordRequest = navParams.get('recordRequest');\n\n    this.queue = this.taskQueueService.findQueue(\"TestDriveRecordPage\") || this.taskQueueService.createQueue(\"TestDriveRecordPage\", {\n      interval: this.POST_TIMEOUT\n    });\n  }\n\n  ionViewDidLeave() {\n\n  }\n\n  private displayTab(display: string) {\n    if (this.tabElement && this.tabElement.style)\n      this.tabElement.style.display = display;\n  }\n  ionViewWillEnter() {\n    this.displayTab('none');\n  }\n  ionViewWillLeave() {\n    this.displayTab('flex');\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n    }\n  }\n  ionViewDidLoad() {\n    this.lastRecordedLocation = null;\n    this.lastPostRecordOrder = 0;\n    this.queue.execute();\n    this.getAddress();\n    this.startTimer();\n    this.watchingDrivenDistance();\n  }\n\n\n\n  private watchingDrivenDistance() {\n    this.drivenMileage = 0;\n    this.geoService.subscribe(\n      (loc: BackgroundGeolocationResponse) => {\n        console.log('Getting new loc ', loc);\n        // this.toastSvc.success('Getting new loc ' + loc.latitude + '-' + loc.longitude);\n        if (this.isTestDriving) {\n          if (this.lastRecordedLocation) {\n            this.drivenMileage += this.geoService.getDistanceFromLatLonInKm(this.lastRecordedLocation.latitude, this.lastRecordedLocation.longitude, loc.latitude, loc.longitude);\n          }\n          this.lastRecordedLocation = loc;\n          console.log('Current mileage ', this.drivenMileage);\n        }\n      }\n    )\n    this.geoService.startRecord();\n    this.pollingExtractLocation();\n\n  }\n  private startTimer() {\n    this.timePassed = this.timePassed || moment.duration();\n    this.displayDrivenDurationInSec = this.timePassed.format('HH:mm:ss', {\n      trim: false\n    });\n    this.timer = setInterval(() => {\n      this.timePassed.add(1, 's');\n      this.displayDrivenDurationInSec = this.timePassed.format('HH:mm:ss', {\n        trim: false\n      })\n    }, 1000);\n  }\n\n  private pollingExtractLocation() {\n    this.postRecordingLocations();\n    this.timeout = setTimeout(() => {\n      this.pollingExtractLocation();\n    }, this.POST_TIMEOUT);\n  }\n  private postRecordingLocations(flushAll?: boolean) {\n    if (this.geoService.getStoredLocations().length > 0) {\n      let bulk_size = flushAll ? this.geoService.getStoredLocations().length : this.RECORD_SIZE;\n      const drivingLocations = this.geoService.getStoredLocations().splice(0, bulk_size).map((loc, index) => {\n        return {\n          latitude: loc.latitude,\n          longitude: loc.longitude,\n          accuracy: loc.accuracy,\n          speed: loc.speed,\n          heading: loc.coords ? loc.coords.heading : null,\n          recordOrder: new Date().getTime(),\n          recordTime: moment(loc.time).toISOString()\n        } as DrivingLocation\n      });\n      const payload = {\n        applicationId: this.drivingRecordRequest.applicationId,\n        drivenDurationInSec: this.timePassed.asSeconds(),\n        drivenMileage: this.drivenMileage,\n        drivingRawRecords: drivingLocations,\n        drivingRecordId: this.recordId\n      } as DrivingRawRecordsRequest;\n\n      const task = new Task(\n        () => {\n          return this.createDrivingRawRecords(payload);\n        }\n      );\n      this.queue.add(task);\n    }\n  }\n\n\n  async endTestDrive() {\n    try {\n\n      const title_first_line = await this.translate.get('test_drive.exit_test_drive_title_first_line').toPromise();\n      const title_second_line = await this.translate.get('test_drive.exit_test_drive_title_second_line').toPromise();\n      const subtitle = await this.translate.get('test_drive.exit_test_drive_subtitle').toPromise();\n\n      let confirm = this.alertCtrl.create({\n        title: `<span>${title_first_line}</span><br><span>${title_second_line}</span>`,\n        message: subtitle,\n        buttons: [\n          {\n            text: this.cancelString,\n            handler: () => {\n            }\n          }, {\n            text: this.okString,\n            handler: async () => {\n              this.isTestDriving = false;\n              this.stopTimer();\n              this.geoService.stop();\n              const loader = await this.loadingSvc.create('msg.posting_test_drive_result');\n              loader.present();\n              try {\n                this.postRecordingLocations(true);\n                this.queue.stop();\n                await this.drivingRecordService.endRecord({\n                  applicationId: this.drivingRecordRequest.applicationId,\n                  drivenDurationInSec: this.timePassed.asSeconds(),\n                  drivenMileage: this.drivenMileage,\n                  driveEndTime: moment().toISOString(),\n                  endLatitude: this.lastRecordedLocation ? this.lastRecordedLocation.latitude : null,\n                  endLongitude: this.lastRecordedLocation ? this.lastRecordedLocation.longitude : null,\n                  id: this.recordId\n                }).toPromise();\n\n                return this.nextToResultPage();\n\n              } catch (err) {\n                this.isTestDriving = true;\n                console.error('[endRecord] fail..', err);\n                // let msg = err.message || 'msg.failed_to_end_driving_record';\n                // this.toastSvc.error(msg);\n              } finally {\n                loader.dismiss();\n              }\n            }\n          }\n        ]\n      });\n      confirm.present();\n    } catch (err) {\n      console.error('[endTestDrive]..', err);\n    }\n  }\n\n  private async createDrivingRawRecords(request: DrivingRawRecordsRequest): Promise<boolean> {\n    let result = false;\n    console.log('[createDrivingRawRecords] DrivingRawRecordsRequest...', request);\n    try {\n      await this.drivingRecordService.createDrivingRawRecords(request).toPromise();\n      result = true;\n    } catch (err) {\n      console.log('[createDrivingRawRecords] fail..', err);\n    }\n    return result;\n  }\n  private nextToResultPage() {\n    this.geoService.stop();\n    this.stopTimer();\n    return this.navCtrl.push(\n      \"TestDriveResultPage\",\n      {\n        item: this.item,\n        applicationId: this.drivingRecordRequest.applicationId,\n        drivenDurationInSec: this.timePassed,\n        drivenMileage: this.drivenMileage\n      })\n  }\n\n  togglePlayButton() {\n    this.isTestDriving = !this.isTestDriving;\n    if (this.isTestDriving) {\n      this.resumeRecording();\n    } else {\n      this.pauseRecording();\n    }\n  }\n\n  private stopTimer() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      // this.timer.clearInterval();\n    }\n  }\n\n  private resumeRecording() {\n    this.startTimer();\n    this.geoService.resumeRecord();\n    this.playButtonIcon = 'pause';\n  }\n  private pauseRecording() {\n    this.stopTimer();\n    this.geoService.pauseRecord();\n    this.playButtonIcon = 'play';\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/test-drive-record/test-drive-record.ts","/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['moment'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but only CommonJS-like\n        // enviroments that support module.exports, like Node.\n        try {\n            module.exports = factory(require('moment'));\n        } catch (e) {\n            // If moment is not available, leave the setup up to the user.\n            // Like when using moment-timezone or similar moment-based package.\n            module.exports = factory;\n        }\n    }\n\n    if (root) {\n        // Globals.\n        root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n    }\n})(this, function (moment) {\n    // `Number#tolocaleString` is tested on plugin initialization.\n    // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n    // native function will be used to generate formatted output. If the feature\n    // test fails, the fallback format function internal to this plugin will be\n    // used.\n    var toLocaleStringWorks = false;\n\n    // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `toLocaleString` will be used for formatting,\n    // the plugin will \"pre-round\" number values using the fallback number format\n    // function before passing them to `toLocaleString` for final formatting.\n    var toLocaleStringRoundingWorks = false;\n\n    // Token type names in order of descending magnitude.\n    var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n\n    var bubbles = [\n        {\n            type: \"seconds\",\n            targets: [\n                { type: \"minutes\", value: 60 },\n                { type: \"hours\", value: 3600 },\n                { type: \"days\", value: 86400 },\n                { type: \"weeks\", value: 604800 },\n                { type: \"months\", value: 2678400 },\n                { type: \"years\", value: 31536000 }\n            ]\n        },\n        {\n            type: \"minutes\",\n            targets: [\n                { type: \"hours\", value: 60 },\n                { type: \"days\", value: 1440 },\n                { type: \"weeks\", value: 10080 },\n                { type: \"months\", value: 44640 },\n                { type: \"years\", value: 525600 }\n            ]\n        },\n        {\n            type: \"hours\",\n            targets: [\n                { type: \"days\", value: 24 },\n                { type: \"weeks\", value: 168 },\n                { type: \"months\", value: 744 },\n                { type: \"years\", value: 8760 }\n            ]\n        },\n        {\n            type: \"days\",\n            targets: [\n                { type: \"weeks\", value: 7 },\n                { type: \"months\", value: 31 },\n                { type: \"years\", value: 365 }\n            ]\n        },\n        {\n            type: \"months\",\n            targets: [\n                { type: \"years\", value: 12 }\n            ]\n        }\n    ];\n\n    // stringIncludes\n    function stringIncludes(str, search) {\n        if (search.length > str.length) {\n          return false;\n        }\n\n        return str.indexOf(search) !== -1;\n    }\n\n    // repeatZero(qty)\n    // Returns \"0\" repeated `qty` times.\n    // `qty` must be a integer >= 0.\n    function repeatZero(qty) {\n        var result = \"\";\n\n        while (qty) {\n            result += \"0\";\n            qty -= 1;\n        }\n\n        return result;\n    }\n\n    function stringRound(digits) {\n        var digitsArray = digits.split(\"\").reverse();\n        var i = 0;\n        var carry = true;\n\n        while (carry && i < digitsArray.length) {\n            if (i) {\n                if (digitsArray[i] === \"9\") {\n                    digitsArray[i] = \"0\";\n                } else {\n                    digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n                    carry = false;\n                }\n            } else {\n                if (parseInt(digitsArray[i], 10) < 5) {\n                    carry = false;\n                }\n\n                digitsArray[i] = \"0\";\n            }\n\n            i += 1;\n        }\n\n        if (carry) {\n            digitsArray.push(\"1\");\n        }\n\n        return digitsArray.reverse().join(\"\");\n    }\n\n    // formatNumber\n    // Formats any number greater than or equal to zero using these options:\n    // - userLocale\n    // - useToLocaleString\n    // - useGrouping\n    // - grouping\n    // - maximumSignificantDigits\n    // - minimumIntegerDigits\n    // - fractionDigits\n    // - groupingSeparator\n    // - decimalSeparator\n    //\n    // `useToLocaleString` will use `toLocaleString` for formatting.\n    // `userLocale` option is passed through to `toLocaleString`.\n    // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n    // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n    function formatNumber(number, options, userLocale) {\n        var useToLocaleString = options.useToLocaleString;\n        var useGrouping = options.useGrouping;\n        var grouping = useGrouping && options.grouping.slice();\n        var maximumSignificantDigits = options.maximumSignificantDigits;\n        var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n        var fractionDigits = options.fractionDigits || 0;\n        var groupingSeparator = options.groupingSeparator;\n        var decimalSeparator = options.decimalSeparator;\n\n        if (useToLocaleString && userLocale) {\n            var localeStringOptions = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                useGrouping: useGrouping\n            };\n\n            if (fractionDigits) {\n                localeStringOptions.maximumFractionDigits = fractionDigits;\n                localeStringOptions.minimumFractionDigits = fractionDigits;\n            }\n\n            // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n            // when maximumSignificantDigits is set. See #96.\n            if (maximumSignificantDigits && number > 0) {\n                localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n            }\n\n            if (!toLocaleStringRoundingWorks) {\n                var roundingOptions = extend({}, options);\n                roundingOptions.useGrouping = false;\n                roundingOptions.decimalSeparator = \".\";\n                number = parseFloat(formatNumber(number, roundingOptions), 10);\n            }\n\n            return number.toLocaleString(userLocale, localeStringOptions);\n        }\n\n        var numberString;\n\n        // Add 1 to digit output length for floating point errors workaround. See below.\n        if (maximumSignificantDigits) {\n            numberString = number.toPrecision(maximumSignificantDigits + 1);\n        } else {\n            numberString = number.toFixed(fractionDigits + 1);\n        }\n\n        var integerString;\n        var fractionString;\n        var exponentString;\n\n        var temp = numberString.split(\"e\");\n\n        exponentString = temp[1] || \"\";\n\n        temp = temp[0].split(\".\");\n\n        fractionString = temp[1] || \"\";\n        integerString = temp[0] || \"\";\n\n        // Workaround for floating point errors in `toFixed` and `toPrecision`.\n        // (3.55).toFixed(1); --> \"3.5\"\n        // (123.55 - 120).toPrecision(2); --> \"3.5\"\n        // (123.55 - 120); --> 3.549999999999997\n        // (123.55 - 120).toFixed(2); --> \"3.55\"\n        // Round by examing the string output of the next digit.\n\n        // *************** Implement String Rounding here ***********************\n        // Check integerString + fractionString length of toPrecision before rounding.\n        // Check length of fractionString from toFixed output before rounding.\n        var integerLength = integerString.length;\n        var fractionLength = fractionString.length;\n        var digitCount = integerLength + fractionLength;\n        var digits = integerString + fractionString;\n\n        if (maximumSignificantDigits && digitCount === (maximumSignificantDigits + 1) || !maximumSignificantDigits && fractionLength === (fractionDigits + 1)) {\n            // Round digits.\n            digits = stringRound(digits);\n\n            if (digits.length === digitCount + 1) {\n                integerLength = integerLength + 1;\n            }\n\n            // Discard final fractionDigit.\n            if (fractionLength) {\n                digits = digits.slice(0, -1);\n            }\n\n            // Separate integer and fraction.\n            integerString = digits.slice(0, integerLength);\n            fractionString = digits.slice(integerLength);\n        }\n\n        // Trim trailing zeroes from fractionString because toPrecision outputs\n        // precision, not significant digits.\n        if (maximumSignificantDigits) {\n            fractionString = fractionString.replace(/0*$/, \"\");\n        }\n\n        // Handle exponent.\n        var exponent = parseInt(exponentString, 10);\n\n        if (exponent > 0) {\n            if (fractionString.length <= exponent) {\n                fractionString = fractionString + repeatZero(exponent - fractionString.length);\n\n                integerString = integerString + fractionString;\n                fractionString = \"\";\n            } else {\n                integerString = integerString + fractionString.slice(0, exponent);\n                fractionString = fractionString.slice(exponent);\n            }\n        } else if (exponent < 0) {\n            fractionString = (repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString);\n\n            integerString = \"0\";\n        }\n\n        if (!maximumSignificantDigits) {\n            // Trim or pad fraction when not using maximumSignificantDigits.\n            fractionString = fractionString.slice(0, fractionDigits);\n\n            if (fractionString.length < fractionDigits) {\n                fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n            }\n\n            // Pad integer when using minimumIntegerDigits\n            // and not using maximumSignificantDigits.\n            if (integerString.length < minimumIntegerDigits) {\n                integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n            }\n        }\n\n        var formattedString = \"\";\n\n        // Handle grouping.\n        if (useGrouping) {\n            temp = integerString;\n            var group;\n\n            while (temp.length) {\n                if (grouping.length) {\n                    group = grouping.shift();\n                }\n\n                if (formattedString) {\n                    formattedString = groupingSeparator + formattedString;\n                }\n\n                formattedString = temp.slice(-group) + formattedString;\n\n                temp = temp.slice(0, -group);\n            }\n        } else {\n            formattedString = integerString;\n        }\n\n        // Add decimalSeparator and fraction.\n        if (fractionString) {\n            formattedString = formattedString + decimalSeparator + fractionString;\n        }\n\n        return formattedString;\n    }\n\n    // durationLabelCompare\n    function durationLabelCompare(a, b) {\n        if (a.label.length > b.label.length) {\n            return -1;\n        }\n\n        if (a.label.length < b.label.length) {\n            return 1;\n        }\n\n        // a must be equal to b\n        return 0;\n    }\n\n    // durationGetLabels\n    function durationGetLabels(token, localeData) {\n        var labels = [];\n\n        each(keys(localeData), function (localeDataKey) {\n            if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n                return;\n            }\n\n            var labelType = localeDataKey.slice(15).toLowerCase();\n\n            each(keys(localeData[localeDataKey]), function (labelKey) {\n                if (labelKey.slice(0, 1) === token) {\n                    labels.push({\n                        type: labelType,\n                        key: labelKey,\n                        label: localeData[localeDataKey][labelKey]\n                    });\n                }\n            });\n        });\n\n        return labels;\n    }\n\n    // durationPluralKey\n    function durationPluralKey(token, integerValue, decimalValue) {\n        // Singular for a value of `1`, but not for `1.0`.\n        if (integerValue === 1 && decimalValue === null) {\n            return token;\n        }\n\n        return token + token;\n    }\n\n    var engLocale = {\n        durationLabelsStandard: {\n            S: 'millisecond',\n            SS: 'milliseconds',\n            s: 'second',\n            ss: 'seconds',\n            m: 'minute',\n            mm: 'minutes',\n            h: 'hour',\n            hh: 'hours',\n            d: 'day',\n            dd: 'days',\n            w: 'week',\n            ww: 'weeks',\n            M: 'month',\n            MM: 'months',\n            y: 'year',\n            yy: 'years'\n        },\n        durationLabelsShort: {\n            S: 'msec',\n            SS: 'msecs',\n            s: 'sec',\n            ss: 'secs',\n            m: 'min',\n            mm: 'mins',\n            h: 'hr',\n            hh: 'hrs',\n            d: 'dy',\n            dd: 'dys',\n            w: 'wk',\n            ww: 'wks',\n            M: 'mo',\n            MM: 'mos',\n            y: 'yr',\n            yy: 'yrs'\n        },\n        durationTimeTemplates: {\n            HMS: 'h:mm:ss',\n            HM: 'h:mm',\n            MS: 'm:ss'\n        },\n        durationLabelTypes: [\n            { type: \"standard\", string: \"__\" },\n            { type: \"short\", string: \"_\" }\n        ],\n        durationPluralKey: durationPluralKey\n    };\n\n    // isArray\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === \"[object Array]\";\n    }\n\n    // isObject\n    function isObject(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Object]\";\n    }\n\n    // findLast\n    function findLast(array, callback) {\n        var index = array.length;\n\n        while (index -= 1) {\n            if (callback(array[index])) { return array[index]; }\n        }\n    }\n\n    // find\n    function find(array, callback) {\n        var index = 0;\n\n        var max = array && array.length || 0;\n\n        var match;\n\n        if (typeof callback !== \"function\") {\n            match = callback;\n            callback = function (item) {\n                return item === match;\n            };\n        }\n\n        while (index < max) {\n            if (callback(array[index])) { return array[index]; }\n            index += 1;\n        }\n    }\n\n    // each\n    function each(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return; }\n\n        while (index < max) {\n            if (callback(array[index], index) === false) { return; }\n            index += 1;\n        }\n    }\n\n    // map\n    function map(array, callback) {\n        var index = 0,\n            max = array.length,\n            ret = [];\n\n        if (!array || !max) { return ret; }\n\n        while (index < max) {\n            ret[index] = callback(array[index], index);\n            index += 1;\n        }\n\n        return ret;\n    }\n\n    // pluck\n    function pluck(array, prop) {\n        return map(array, function (item) {\n            return item[prop];\n        });\n    }\n\n    // compact\n    function compact(array) {\n        var ret = [];\n\n        each(array, function (item) {\n            if (item) { ret.push(item); }\n        });\n\n        return ret;\n    }\n\n    // unique\n    function unique(array) {\n        var ret = [];\n\n        each(array, function (_a) {\n            if (!find(ret, _a)) { ret.push(_a); }\n        });\n\n        return ret;\n    }\n\n    // intersection\n    function intersection(a, b) {\n        var ret = [];\n\n        each(a, function (_a) {\n            each(b, function (_b) {\n                if (_a === _b) { ret.push(_a); }\n            });\n        });\n\n        return unique(ret);\n    }\n\n    // rest\n    function rest(array, callback) {\n        var ret = [];\n\n        each(array, function (item, index) {\n            if (!callback(item)) {\n                ret = array.slice(index);\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    // initial\n    function initial(array, callback) {\n        var reversed = array.slice().reverse();\n\n        return rest(reversed, callback).reverse();\n    }\n\n    // extend\n    function extend(a, b) {\n        for (var key in b) {\n            if (b.hasOwnProperty(key)) { a[key] = b[key]; }\n        }\n\n        return a;\n    }\n\n    // keys\n    function keys(a) {\n        var ret = [];\n\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) { ret.push(key); }\n        }\n\n        return ret;\n    }\n\n    // any\n    function any(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return false; }\n\n        while (index < max) {\n            if (callback(array[index], index) === true) { return true; }\n            index += 1;\n        }\n\n        return false;\n    }\n\n    // flatten\n    function flatten(array) {\n        var ret = [];\n\n        each(array, function(child) {\n            ret = ret.concat(child);\n        });\n\n        return ret;\n    }\n\n    function toLocaleStringSupportsLocales() {\n        var number = 0;\n        try {\n            number.toLocaleString('i');\n        } catch (e) {\n            return e.name === 'RangeError';\n        }\n        return false;\n    }\n\n    function featureTestToLocaleStringRounding() {\n        return (3.55).toLocaleString(\"en\", {\n            useGrouping: false,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: 1,\n            maximumFractionDigits: 1\n        }) === \"3.6\";\n    }\n\n    function featureTestToLocaleString() {\n        var passed = true;\n\n        // Test locale.\n        passed = passed && toLocaleStringSupportsLocales();\n        if (!passed) { return false; }\n\n        // Test minimumIntegerDigits.\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 1 }) === \"1\";\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 2 }) === \"01\";\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 3 }) === \"001\";\n        if (!passed) { return false; }\n\n        // Test maximumFractionDigits and minimumFractionDigits.\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 0, minimumFractionDigits: 0 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 1, minimumFractionDigits: 1 }) === \"100.0\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 2, minimumFractionDigits: 2 }) === \"99.99\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 3, minimumFractionDigits: 3 }) === \"99.990\";\n        if (!passed) { return false; }\n\n        // Test maximumSignificantDigits.\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 1 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 2 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 3 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 4 }) === \"99.99\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 5 }) === \"99.99\";\n        if (!passed) { return false; }\n\n        // Test grouping.\n        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: true }) === \"1,000\";\n        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: false }) === \"1000\";\n        if (!passed) { return false; }\n\n        return true;\n    }\n\n    // durationsFormat(durations [, template] [, precision] [, settings])\n    function durationsFormat() {\n        var args = [].slice.call(arguments);\n        var settings = {};\n        var durations;\n\n        // Parse arguments.\n        each(args, function (arg, index) {\n            if (!index) {\n                if (!isArray(arg)) {\n                    throw \"Expected array as the first argument to durationsFormat.\";\n                }\n\n                durations = arg;\n            }\n\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        if (!durations || !durations.length) {\n            return [];\n        }\n\n        settings.returnMomentTypes = true;\n\n        var formattedDurations = map(durations, function (dur) {\n            return dur.format(settings);\n        });\n\n        // Merge token types from all durations.\n        var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n\n        var largest = settings.largest;\n\n        if (largest) {\n            outputTypes = outputTypes.slice(0, largest);\n        }\n\n        settings.returnMomentTypes = false;\n        settings.outputTypes = outputTypes;\n\n        return map(durations, function (dur) {\n            return dur.format(settings);\n        });\n    }\n\n    // durationFormat([template] [, precision] [, settings])\n    function durationFormat() {\n\n        var args = [].slice.call(arguments);\n        var settings = extend({}, this.format.defaults);\n\n        // Keep a shadow copy of this moment for calculating remainders.\n        // Perform all calculations on positive duration value, handle negative\n        // sign at the very end.\n        var asMilliseconds = this.asMilliseconds();\n        var asMonths = this.asMonths();\n\n        // Treat invalid durations as having a value of 0 milliseconds.\n        if (typeof this.isValid === \"function\" && this.isValid() === false) {\n            asMilliseconds = 0;\n            asMonths = 0;\n        }\n\n        var isNegative = asMilliseconds < 0;\n\n        // Two shadow copies are needed because of the way moment.js handles\n        // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n        var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n        var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n        // Parse arguments.\n        each(args, function (arg) {\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        var momentTokens = {\n            years: \"y\",\n            months: \"M\",\n            weeks: \"w\",\n            days: \"d\",\n            hours: \"h\",\n            minutes: \"m\",\n            seconds: \"s\",\n            milliseconds: \"S\"\n        };\n\n        var tokenDefs = {\n            escape: /\\[(.+?)\\]/,\n            years: /\\*?[Yy]+/,\n            months: /\\*?M+/,\n            weeks: /\\*?[Ww]+/,\n            days: /\\*?[Dd]+/,\n            hours: /\\*?[Hh]+/,\n            minutes: /\\*?m+/,\n            seconds: /\\*?s+/,\n            milliseconds: /\\*?S+/,\n            general: /.+?/\n        };\n\n        // Types array is available in the template function.\n        settings.types = types;\n\n        var typeMap = function (token) {\n            return find(types, function (type) {\n                return tokenDefs[type].test(token);\n            });\n        };\n\n        var tokenizer = new RegExp(map(types, function (type) {\n            return tokenDefs[type].source;\n        }).join(\"|\"), \"g\");\n\n        // Current duration object is available in the template function.\n        settings.duration = this;\n\n        // Eval template function and cache template string.\n        var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n        // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n        // outputTypes is an array of moment token types that determines\n        // the tokens returned in formatted output. This option overrides\n        // trim, largest, stopTrim, etc.\n        var outputTypes = settings.outputTypes;\n\n        // returnMomentTypes is a boolean that sets durationFormat to return\n        // the processed momentTypes instead of formatted output.\n        var returnMomentTypes = settings.returnMomentTypes;\n\n        var largest = settings.largest;\n\n        // Setup stopTrim array of token types.\n        var stopTrim = [];\n\n        if (!outputTypes) {\n            if (isArray(settings.stopTrim)) {\n                settings.stopTrim = settings.stopTrim.join(\"\");\n            }\n\n            // Parse stopTrim string to create token types array.\n            if (settings.stopTrim) {\n                each(settings.stopTrim.match(tokenizer), function (token) {\n                    var type = typeMap(token);\n\n                    if (type === \"escape\" || type === \"general\") {\n                        return;\n                    }\n\n                    stopTrim.push(type);\n                });\n            }\n        }\n\n        // Cache moment's locale data.\n        var localeData = moment.localeData();\n\n        if (!localeData) {\n            localeData = {};\n        }\n\n        // Fall back to this plugin's `eng` extension.\n        each(keys(engLocale), function (key) {\n            if (typeof engLocale[key] === \"function\") {\n                if (!localeData[key]) {\n                    localeData[key] = engLocale[key];\n                }\n\n                return;\n            }\n\n            if (!localeData[\"_\" + key]) {\n                localeData[\"_\" + key] = engLocale[key];\n            }\n        });\n\n        // Replace Duration Time Template strings.\n        // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n        each(keys(localeData._durationTimeTemplates), function (item) {\n            template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n        });\n\n        // Determine user's locale.\n        var userLocale = settings.userLocale || moment.locale();\n\n        var useLeftUnits = settings.useLeftUnits;\n        var usePlural = settings.usePlural;\n        var precision = settings.precision;\n        var forceLength = settings.forceLength;\n        var useGrouping = settings.useGrouping;\n        var trunc = settings.trunc;\n\n        // Use significant digits only when precision is greater than 0.\n        var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n        var significantDigits = useSignificantDigits ? settings.precision : 0;\n        var significantDigitsCache = significantDigits;\n\n        var minValue = settings.minValue;\n        var isMinValue = false;\n\n        var maxValue = settings.maxValue;\n        var isMaxValue = false;\n\n        // formatNumber fallback options.\n        var useToLocaleString = settings.useToLocaleString;\n        var groupingSeparator = settings.groupingSeparator;\n        var decimalSeparator = settings.decimalSeparator;\n        var grouping = settings.grouping;\n\n        useToLocaleString = useToLocaleString && toLocaleStringWorks;\n\n        // Trim options.\n        var trim = settings.trim;\n\n        if (isArray(trim)) {\n            trim = trim.join(\" \");\n        }\n\n        if (trim === null && (largest || maxValue || useSignificantDigits)) {\n            trim = \"all\";\n        }\n\n        if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n            trim = \"large\";\n        }\n\n        if (trim === false) {\n            trim = \"\";\n        }\n\n        var trimIncludes = function (item) {\n            return item.test(trim);\n        };\n\n        var rLarge = /large/;\n        var rSmall = /small/;\n        var rBoth = /both/;\n        var rMid = /mid/;\n        var rAll = /^all|[^sm]all/;\n        var rFinal = /final/;\n\n        var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n        var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n        var trimMid = any([rMid, rAll], trimIncludes);\n        var trimFinal = any([rFinal, rAll], trimIncludes);\n\n        // Parse format string to create raw tokens array.\n        var rawTokens = map(template.match(tokenizer), function (token, index) {\n            var type = typeMap(token);\n\n            if (token.slice(0, 1) === \"*\") {\n                token = token.slice(1);\n\n                if (type !== \"escape\" && type !== \"general\") {\n                    stopTrim.push(type);\n                }\n            }\n\n            return {\n                index: index,\n                length: token.length,\n                text: \"\",\n\n                // Replace escaped tokens with the non-escaped token text.\n                token: (type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token),\n\n                // Ignore type on non-moment tokens.\n                type: ((type === \"escape\" || type === \"general\") ? null : type)\n            };\n        });\n\n        // Associate text tokens with moment tokens.\n        var currentToken = {\n            index: 0,\n            length: 0,\n            token: \"\",\n            text: \"\",\n            type: null\n        };\n\n        var tokens = [];\n\n        if (useLeftUnits) {\n            rawTokens.reverse();\n        }\n\n        each(rawTokens, function (token) {\n            if (token.type) {\n                if (currentToken.type || currentToken.text) {\n                    tokens.push(currentToken);\n                }\n\n                currentToken = token;\n\n                return;\n            }\n\n            if (useLeftUnits) {\n                currentToken.text = token.token + currentToken.text;\n            } else {\n                currentToken.text += token.token;\n            }\n        });\n\n        if (currentToken.type || currentToken.text) {\n            tokens.push(currentToken);\n        }\n\n        if (useLeftUnits) {\n            tokens.reverse();\n        }\n\n        // Find unique moment token types in the template in order of\n        // descending magnitude.\n        var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n        // Exit early if there are no moment token types.\n        if (!momentTypes.length) {\n            return pluck(tokens, \"text\").join(\"\");\n        }\n\n        // Calculate values for each moment type in the template.\n        // For processing the settings, values are associated with moment types.\n        // Values will be assigned to tokens at the last step in order to\n        // assume nothing about frequency or order of tokens in the template.\n        momentTypes = map(momentTypes, function (momentType, index) {\n            // Is this the least-magnitude moment token found?\n            var isSmallest = ((index + 1) === momentTypes.length);\n\n            // Is this the greatest-magnitude moment token found?\n            var isLargest = (!index);\n\n            // Get the raw value in the current units.\n            var rawValue;\n\n            if (momentType === \"years\" || momentType === \"months\") {\n                rawValue = remainderMonths.as(momentType);\n            } else {\n                rawValue = remainder.as(momentType);\n            }\n\n            var wholeValue = Math.floor(rawValue);\n            var decimalValue = rawValue - wholeValue;\n\n            var token = find(tokens, function (token) {\n                return momentType === token.type;\n            });\n\n            if (isLargest && maxValue && rawValue > maxValue) {\n                isMaxValue = true;\n            }\n\n            if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n                isMinValue = true;\n            }\n\n            // Note the length of the largest-magnitude moment token:\n            // if it is greater than one and forceLength is not set,\n            // then default forceLength to `true`.\n            //\n            // Rationale is this: If the template is \"h:mm:ss\" and the\n            // moment value is 5 minutes, the user-friendly output is\n            // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n            // even though it has length of two if the template is \"h:mm:ss\";\n            //\n            // If the minutes output should always include the leading zero\n            // even when the hour is trimmed then set `{ forceLength: true }`\n            // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n            // clearly wanted everything padded so we should output \"05:00\";\n            //\n            // If the user wants the full padded output, they can use\n            // template \"hh:mm:ss\" and set `{ trim: false }` to output\n            // \"00:05:00\".\n            if (isLargest && forceLength === null && token.length > 1) {\n                forceLength = true;\n            }\n\n            // Update remainder.\n            remainder.subtract(wholeValue, momentType);\n            remainderMonths.subtract(wholeValue, momentType);\n\n            return {\n                rawValue: rawValue,\n                wholeValue: wholeValue,\n                // Decimal value is only retained for the least-magnitude\n                // moment type in the format template.\n                decimalValue: isSmallest ? decimalValue : 0,\n                isSmallest: isSmallest,\n                isLargest: isLargest,\n                type: momentType,\n                // Tokens can appear multiple times in a template string,\n                // but all instances must share the same length.\n                tokenLength: token.length\n            };\n        });\n\n        var truncMethod = trunc ? Math.floor : Math.round;\n        var truncate = function (value, places) {\n            var factor = Math.pow(10, places);\n            return truncMethod(value * factor) / factor;\n        };\n\n        var foundFirst = false;\n        var bubbled = false;\n\n        var formatValue = function (momentType, index) {\n            var formatOptions = {\n                useGrouping: useGrouping,\n                groupingSeparator: groupingSeparator,\n                decimalSeparator: decimalSeparator,\n                grouping: grouping,\n                useToLocaleString: useToLocaleString\n            };\n\n            if (useSignificantDigits) {\n                if (significantDigits <= 0) {\n                    momentType.rawValue = 0;\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                } else {\n                    formatOptions.maximumSignificantDigits = significantDigits;\n                    momentType.significantDigits = significantDigits;\n                }\n            }\n\n            if (isMaxValue && !bubbled) {\n                if (momentType.isLargest) {\n                    momentType.wholeValue = maxValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (isMinValue && !bubbled) {\n                if (momentType.isSmallest) {\n                    momentType.wholeValue = minValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n                // Apply precision to least significant token value.\n                if (precision < 0) {\n                    momentType.value = truncate(momentType.wholeValue, precision);\n                } else if (precision === 0) {\n                    momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n                } else { // precision > 0\n                    if (useSignificantDigits) {\n                        if (trunc) {\n                            momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n                        } else {\n                            momentType.value = momentType.rawValue;\n                        }\n\n                        if (momentType.wholeValue) {\n                            significantDigits -= momentType.wholeValue.toString().length;\n                        }\n                    } else {\n                        formatOptions.fractionDigits = precision;\n\n                        if (trunc) {\n                            momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n                        } else {\n                            momentType.value = momentType.wholeValue + momentType.decimalValue;\n                        }\n                    }\n                }\n            } else {\n                if (useSignificantDigits && momentType.wholeValue) {\n                    // Outer Math.round required here to handle floating point errors.\n                    momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n\n                    significantDigits -= momentType.wholeValue.toString().length;\n                } else {\n                    momentType.value = momentType.wholeValue;\n                }\n            }\n\n            if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n                formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n                if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n                    delete formatOptions.maximumSignificantDigits;\n                }\n            }\n\n            if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                foundFirst = true;\n            }\n\n            momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n\n            formatOptions.useGrouping = false;\n            formatOptions.decimalSeparator = \".\";\n            momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n            if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n                momentType.formattedValueMS = formatNumber(momentType.value, {\n                    minimumIntegerDigits: 3,\n                    useGrouping: false\n                }, \"en\").slice(0, 2);\n            }\n\n            return momentType;\n        };\n\n        // Calculate formatted values.\n        momentTypes = map(momentTypes, formatValue);\n        momentTypes = compact(momentTypes);\n\n        // Bubble rounded values.\n        if (momentTypes.length > 1) {\n            var findType = function (type) {\n                return find(momentTypes, function (momentType) {\n                    return momentType.type === type;\n                });\n            };\n\n            var bubbleTypes = function (bubble) {\n                var bubbleMomentType = findType(bubble.type);\n\n                if (!bubbleMomentType) {\n                    return;\n                }\n\n                each(bubble.targets, function (target) {\n                    var targetMomentType = findType(target.type);\n\n                    if (!targetMomentType) {\n                        return;\n                    }\n\n                    if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n                        bubbleMomentType.rawValue = 0;\n                        bubbleMomentType.wholeValue = 0;\n                        bubbleMomentType.decimalValue = 0;\n                        targetMomentType.rawValue += 1;\n                        targetMomentType.wholeValue += 1;\n                        targetMomentType.decimalValue = 0;\n                        targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n                        bubbled = true;\n                    }\n                });\n            };\n\n            each(bubbles, bubbleTypes);\n        }\n\n        // Recalculate formatted values.\n        if (bubbled) {\n            foundFirst = false;\n            significantDigits = significantDigitsCache;\n            momentTypes = map(momentTypes, formatValue);\n            momentTypes = compact(momentTypes);\n        }\n\n        if (outputTypes && !(isMaxValue && !settings.trim)) {\n            momentTypes = map(momentTypes, function (momentType) {\n                if (find(outputTypes, function (outputType) {\n                    return momentType.type === outputType;\n                })) {\n                    return momentType;\n                }\n\n                return null;\n            });\n\n            momentTypes = compact(momentTypes);\n        } else {\n            // Trim Large.\n            if (trimLarge) {\n                momentTypes = rest(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - the smallest moment type\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n                });\n            }\n\n            // Largest.\n            if (largest && momentTypes.length) {\n                momentTypes = momentTypes.slice(0, largest);\n            }\n\n            // Trim Small.\n            if (trimSmall && momentTypes.length > 1) {\n                momentTypes = initial(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    // - the largest momentType\n                    return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n                });\n            }\n\n            // Trim Mid.\n            if (trimMid) {\n                momentTypes = map(momentTypes, function (momentType, index) {\n                    if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n                        return null;\n                    }\n\n                    return momentType;\n                });\n\n                momentTypes = compact(momentTypes);\n            }\n\n            // Trim Final.\n            if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n                momentTypes = [];\n            }\n        }\n\n        if (returnMomentTypes) {\n            return momentTypes;\n        }\n\n        // Localize and pluralize unit labels.\n        each(tokens, function (token) {\n            var key = momentTokens[token.type];\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!key || !momentType) {\n                return;\n            }\n\n            var values = momentType.formattedValueEn.split(\".\");\n\n            values[0] = parseInt(values[0], 10);\n\n            if (values[1]) {\n                values[1] = parseFloat(\"0.\" + values[1], 10);\n            } else {\n                values[1] = null;\n            }\n\n            var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n\n            var labels = durationGetLabels(key, localeData);\n\n            var autoLocalized = false;\n\n            var pluralizedLabels = {};\n\n            // Auto-Localized unit labels.\n            each(localeData._durationLabelTypes, function (labelType) {\n                var label = find(labels, function (label) {\n                    return label.type === labelType.type && label.key === pluralKey;\n                });\n\n                if (label) {\n                    pluralizedLabels[label.type] = label.label;\n\n                    if (stringIncludes(token.text, labelType.string)) {\n                        token.text = token.text.replace(labelType.string, label.label);\n                        autoLocalized = true;\n                    }\n                }\n            });\n\n            // Auto-pluralized unit labels.\n            if (usePlural && !autoLocalized) {\n                labels.sort(durationLabelCompare);\n\n                each(labels, function (label) {\n                    if (pluralizedLabels[label.type] === label.label) {\n                        if (stringIncludes(token.text, label.label)) {\n                            // Stop checking this token if its label is already\n                            // correctly pluralized.\n                            return false;\n                        }\n\n                        // Skip this label if it is correct, but not present in\n                        // the token's text.\n                        return;\n                    }\n\n                    if (stringIncludes(token.text, label.label)) {\n                        // Replece this token's label and stop checking.\n                        token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n                        return false;\n                    }\n                });\n            }\n        });\n\n        // Build ouptut.\n        tokens = map(tokens, function (token) {\n            if (!token.type) {\n                return token.text;\n            }\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!momentType) {\n                return \"\";\n            }\n\n            var out = \"\";\n\n            if (useLeftUnits) {\n                out += token.text;\n            }\n\n            if (isNegative && isMaxValue || !isNegative && isMinValue) {\n                out += \"< \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && isMinValue || !isNegative && isMaxValue) {\n                out += \"> \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                out += \"-\";\n                isNegative = false;\n            }\n\n            if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n                out += momentType.formattedValueMS;\n            } else {\n                out += momentType.formattedValue;\n            }\n\n            if (!useLeftUnits) {\n                out += token.text;\n            }\n\n            return out;\n        });\n\n        // Trim leading and trailing comma, space, colon, and dot.\n        return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n    }\n\n    // defaultFormatTemplate\n    function defaultFormatTemplate() {\n        var dur = this.duration;\n\n        var findType = function findType(type) {\n            return dur._data[type];\n        };\n\n        var firstType = find(this.types, findType);\n\n        var lastType = findLast(this.types, findType);\n\n        // Default template strings for each duration dimension type.\n        switch (firstType) {\n            case \"milliseconds\":\n                return \"S __\";\n            case \"seconds\": // Fallthrough.\n            case \"minutes\":\n                return \"*_MS_\";\n            case \"hours\":\n                return \"_HMS_\";\n            case \"days\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"d __\";\n                }\n            case \"weeks\":\n                if (firstType === lastType) {\n                    return \"w __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"w __, d __, h __\";\n            case \"months\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"M __\";\n                }\n            case \"years\":\n                if (firstType === lastType) {\n                    return \"y __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, M __, d __\";\n            default:\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, d __, h __, m __, s __\";\n        }\n    }\n\n    // init\n    function init(context) {\n        if (!context) {\n            throw \"Moment Duration Format init cannot find moment instance.\";\n        }\n\n        context.duration.format = durationsFormat;\n        context.duration.fn.format = durationFormat;\n\n        context.duration.fn.format.defaults = {\n            // Many options are defaulted to `null` to distinguish between\n            // 'not set' and 'set to `false`'\n\n            // trim\n            // Can be a string, a delimited list of strings, an array of strings,\n            // or a boolean.\n            // \"large\" - will trim largest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"small\" - will trim smallest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"both\" - will execute \"large\" trim then \"small\" trim.\n            // \"mid\" - will trim any zero-value tokens that are not the first or\n            // last tokens. Usually used in conjunction with \"large\" or \"both\".\n            // e.g. \"large mid\" or \"both mid\".\n            // \"final\" - will trim the final token if it is zero-value. Use this\n            // option with \"large\" or \"both\" to output an empty string when\n            // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n            // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n            // \"left\" - maps to \"large\" to support plugin's version 1 API.\n            // \"right\" - maps to \"large\" to support plugin's version 1 API.\n            // `false` - template tokens are not trimmed.\n            // `true` - treated as \"large\".\n            // `null` - treated as \"large\".\n            trim: null,\n\n            // stopTrim\n            // A moment token string, a delimited set of moment token strings,\n            // or an array of moment token strings. Trimming will stop when a token\n            // listed in this option is reached. A \"*\" character in the format\n            // template string will also mark a moment token as stopTrim.\n            // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n            stopTrim: null,\n\n            // largest\n            // Set to a positive integer to output only the \"n\" largest-magnitude\n            // moment tokens that have a value. All lesser-magnitude moment tokens\n            // will be ignored. This option takes effect even if `trim` is set\n            // to `false`.\n            largest: null,\n\n            // maxValue\n            // Use `maxValue` to render generalized output for large duration values,\n            // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n            /// applied to the greatest-magnitude moment token in the format template.\n            maxValue: null,\n\n            // minValue\n            // Use `minValue` to render generalized output for small duration values,\n            // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n            // applied to the least-magnitude moment token in the format template.\n            minValue: null,\n\n            // precision\n            // If a positive integer, number of decimal fraction digits to render.\n            // If a negative integer, number of integer place digits to truncate to 0.\n            // If `useSignificantDigits` is set to `true` and `precision` is a positive\n            // integer, sets the maximum number of significant digits used in the\n            // formatted output.\n            precision: 0,\n\n            // trunc\n            // Default behavior rounds final token value. Set to `true` to\n            // truncate final token value, which was the default behavior in\n            // version 1 of this plugin.\n            trunc: false,\n\n            // forceLength\n            // Force first moment token with a value to render at full length\n            // even when template is trimmed and first moment token has length of 1.\n            forceLength: null,\n\n            // userLocale\n            // Formatted numerical output is rendered using `toLocaleString`\n            // and the locale of the user's environment. Set this option to render\n            // numerical output using a different locale. Unit names are rendered\n            // and detected using the locale set in moment.js, which can be different\n            // from the locale of user's environment.\n            userLocale: null,\n\n            // usePlural\n            // Will automatically singularize or pluralize unit names when they\n            // appear in the text associated with each moment token. Standard and\n            // short unit labels are singularized and pluralized, based on locale.\n            // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n            // of \"1 seconds\" or \"1 secs\". The default pluralization function\n            // renders a plural label for a value with decimal precision.\n            // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n            // Label types and pluralization function are configurable in the\n            // localeData extensions.\n            usePlural: true,\n\n            // useLeftUnits\n            // The text to the right of each moment token in a format string\n            // is treated as that token's units for the purposes of trimming,\n            // singularizing, and auto-localizing.\n            // e.g. \"h [hours], m [minutes], s [seconds]\".\n            // To properly singularize or localize a format string such as\n            // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n            // to the left of each moment token, set useLeftUnits to `true`.\n            // This plugin is not tested in the context of rtl text.\n            useLeftUnits: false,\n\n            // useGrouping\n            // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useGrouping: true,\n\n            // useSignificantDigits\n            // Treat the `precision` option as the maximum significant digits\n            // to be rendered. Precision must be a positive integer. Significant\n            // digits extend across unit types,\n            // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n            // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useSignificantDigits: false,\n\n            // template\n            // The template string used to format the duration. May be a function\n            // or a string. Template functions are executed with the `this` binding\n            // of the settings object so that template strings may be dynamically\n            // generated based on the duration object (accessible via `this.duration`)\n            // or any of the other settings. Leading and trailing space, comma,\n            // period, and colon characters are trimmed from the resulting string.\n            template: defaultFormatTemplate,\n\n            // useToLocaleString\n            // Set this option to `false` to ignore the `toLocaleString` feature\n            // test and force the use of the `formatNumber` fallback function\n            // included in this plugin.\n            useToLocaleString: true,\n\n            // formatNumber fallback options.\n            // When `toLocaleString` is detected and passes the feature test, the\n            // following options will have no effect: `toLocaleString` will be used\n            // for formatting and the grouping separator, decimal separator, and\n            // integer digit grouping will be determined by the user locale.\n\n            // groupingSeparator\n            // The integer digit grouping separator used when using the fallback\n            // formatNumber function.\n            groupingSeparator: \",\",\n\n            // decimalSeparator\n            // The decimal separator used when using the fallback formatNumber\n            // function.\n            decimalSeparator: \".\",\n\n            // grouping\n            // The integer digit grouping used when using the fallback formatNumber\n            // function. Must be an array. The default value of `[3]` gives the\n            // standard 3-digit thousand/million/billion digit groupings for the\n            // \"en\" locale. Setting this option to `[3, 2]` would generate the\n            // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n            grouping: [3]\n        };\n\n        context.updateLocale('en', engLocale);\n    }\n\n    // Run feature tests for `Number#toLocaleString`.\n    toLocaleStringWorks = featureTestToLocaleString();\n    toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestToLocaleStringRounding();\n\n    // Initialize duration format on the global moment instance.\n    init(moment);\n\n    // Return the init function so that duration format can be\n    // initialized on other moment instances.\n    return init;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/moment-duration-format/lib/moment-duration-format.js\n// module id = 800\n// module chunks = 1"],"sourceRoot":""}
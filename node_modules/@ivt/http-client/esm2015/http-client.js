import { Injectable, NgModule } from '@angular/core';
import { HttpResponse, HTTP_INTERCEPTORS, HttpClientModule } from '@angular/common/http';
import { map, catchError } from 'rxjs/operators';
import { plainToClass } from 'class-transformer';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/throw';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class IvtHttpClientConfig {
    /**
     *
     * @param {?} request
     * Transform request before invoking API
     * @return {?}
     */
    transformRequestBody(request) {
        return null;
    }
    /**
     *
     * @param {?} response
     * Transform response from API
     * @return {?}
     */
    transformResponseBody(response) {
        return null;
    }
    /**
     * Provide Authorization Header
     * @return {?}
     */
    getAuthorizationHeader() {
        throw new Error('Not Implemented');
    }
}
IvtHttpClientConfig.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class IvtHttpInterceptor {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        let /** @type {?} */ clonedReq = null;
        if (req.params.get('auth') !== 'false') {
            clonedReq = clonedReq || {};
            clonedReq.headers = req.headers.set('Authorization', this.config.getAuthorizationHeader());
        }
        if (req.method === 'POST') {
            const /** @type {?} */ transformedBody = this.config.transformRequestBody(req);
            if (transformedBody != null) {
                clonedReq = clonedReq || {};
                clonedReq.body = transformedBody;
            }
            else {
                console.log('[IvtHttpInterceptor] transformRequest() is null, request body is not transformed');
            }
        }
        if (clonedReq != null) {
            req = req.clone(clonedReq);
        }
        return next.handle(req).pipe(map(response => {
            if (response instanceof HttpResponse) {
                const /** @type {?} */ transformedBody = this.config.transformResponseBody(response);
                if (transformedBody != null) {
                    response = response.clone({
                        body: transformedBody
                    });
                }
                else {
                    console.log('[IvtHttpInterceptor] transformResponse() is null, response body is not transformed');
                }
            }
            return response;
        }));
    }
}
IvtHttpInterceptor.decorators = [
    { type: Injectable },
];
/** @nocollapse */
IvtHttpInterceptor.ctorParameters = () => [
    { type: IvtHttpClientConfig, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class APICode {
}
APICode.ClientError = 'ClientError';
APICode.Progress = 'Progress';
APICode.Success = '1';
APICode.TokenInvalid = '401';
APICode.ParameterMissing = '-400';
APICode.InternalServerError = '-500';
APICode.FailedToCreateAppointment = '-510';
APICode.NoAppointmentFound = '-511';
APICode.FailedToCreateRepairOrder = '-600';
APICode.FailedToCreateRepairOrderDueToOpenRepairOrderAlreadyExist = '-601';
APICode.FailedToUpdateRepairOrder = '-620';
APICode.CannotIssueRODueToAlreadyIssued = '-630';
APICode.CannotCompleteServiceDueToAlreadyCompleted = '-640';
APICode.FailedToCompleteService = -641;
APICode.CannotCancelRepairOrderDueToAlreadyCanceled = '-642';
APICode.CannotCancelRepairOrderDueToAlreadyCompleted = '-643';
APICode.CannotCheckInDueToNonAppointment = '-644';
APICode.CannotIssueDueToNonPreRO = '-650';
APICode.NotAllowedFileFormat = '-730';
APICode.NoChecklistFound = '-900';
APICode.FailedToSaveChecklist = '-901';
APICode.FailedToSendMessage = '-1000';
APICode.FailedToCreateScheduleItem = '-1100';
APICode.OrganizationNotFound = '-1200';
APICode.UserNotFound = '-1201';
APICode.QLTokenWrong = '-1202';
APICode.QLTokenExpired = '-1203';
APICode.DealerPushServerSettingMissing = '-1204';
APICode.Undefined = '-99999';
APICode.Timeout = '-90000';
APICode.CannotConnectToServer = '-90001';
APICode.KickedOut = 'HOST_COMMON_6000';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ErrorLevel {
}
ErrorLevel.Critical = 'critical';
ErrorLevel.Normal = 'normal';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class APIResponse {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class IvtHttpService {
    /**
     * @param {?} httpClient
     * @param {?} url
     * @param {?} ClazzType
     * @param {?} config
     */
    constructor(httpClient, url, ClazzType, config) {
        this.httpClient = httpClient;
        this.url = url;
        this.ClazzType = ClazzType;
        this.config = config;
    }
    /**
     * @param {?} res
     * @return {?}
     */
    extractData(res) {
        const /** @type {?} */ response = /** @type {?} */ ((res));
        if (response.code === APICode.Success) {
            if (response.data instanceof Array) {
                return plainToClass(this.ClazzType, response.data);
            }
            else {
                return plainToClass(this.ClazzType, response.data);
            }
        }
        throw response;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        let /** @type {?} */ response = new APIResponse();
        if (error.error instanceof ErrorEvent) {
            // A client-side or network error occurred. Handle it accordingly.
            console.error('[ServicesBase]: An error occurred:', error.error.message);
            response.code = APICode.ClientError;
            response.message = error.error.message;
        }
        else if (error instanceof APIResponse) {
            return Observable.throw(error);
        }
        else if (error instanceof Error) {
            response.code = APICode.ClientError;
            response.message = error.message;
        }
        else if (error.error instanceof ProgressEvent) {
            response.code = APICode.Progress;
            response.event = error.error;
        }
        else {
            // The backend returned an unsuccessful response code.
            // The response body may contain clues as to what went wrong,
            const /** @type {?} */ transformedResponse = this.config.transformResponseBody(error);
            if (transformedResponse) {
                response = transformedResponse;
            }
            else {
                // transformResponse is not implemented
                response = error.error;
            }
            response.code = error.status.toString();
            console.error(`[ServicesBase]: Backend returned code ${response.code}, ` +
                `body was: ${response.message}`);
        }
        return Observable.throw(response);
    }
    ;
    /**
     * @param {?=} parentId
     * @return {?}
     */
    getAll(parentId) {
        return this.httpClient.get(this.url + (parentId ? `/${parentId}` : ''))
            .pipe(map(res => this.extractData(res)))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * @param {?} id
     * @return {?}
     */
    get(id) {
        return this.httpClient.get(this.url + (id ? `/${id}` : ''))
            .pipe(map(res => this.extractData(res)))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    save(item) {
        return this.httpClient.post(this.url, item)
            .pipe(map(res => this.extractData(res)))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * @param {?=} criteria
     * @return {?}
     */
    search(criteria) {
        return this.httpClient.post(this.url, criteria)
            .pipe(map(res => this.extractData(res)))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * @param {?} id
     * @return {?}
     */
    delete(id) {
        return this.httpClient.delete(this.url + (id ? `/${id}` : ''))
            .pipe(map(res => this.extractData(res)))
            .pipe(catchError(err => this.handleError(err)));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class IvtHttpClientModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: IvtHttpClientModule,
            providers: [
                IvtHttpClientConfig,
                { provide: HTTP_INTERCEPTORS, useClass: IvtHttpInterceptor, multi: true }
            ]
        };
    }
}
IvtHttpClientModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { APICode, ErrorLevel, APIResponse, IvtHttpInterceptor, IvtHttpClientConfig, IvtHttpService, IvtHttpClientModule };
//# sourceMappingURL=http-client.js.map
